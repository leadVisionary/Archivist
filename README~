An initial prototype for the Archivist archetype of the rzr-js reference model.
An archetype is a meta-level pattern encountered in many different applications,typically revolving around providing a certain set of functionality. 

For example, applications that depend on REST APIs often have a Service Layer http://martinfowler.com/eaaCatalog/serviceLayer.html component devoted specifically toexternal interfacing with the target API through an HTTP client library. In rzr-js, this is manifested as the Scout archetype. 

Like a scout in a combat company, the Scout archtype embodies the responsibilityof retrieving information from distant locations. Scouts are responsible for knowing 
- how to get to where they need to go (A RetrievalStrategy)  
- what their dispatchers are looking for (A FilteringStrategy)
- how the information they return is to be conveyed (A FormattingStrategy)

A particular type of Scout, for example an ESPNScout, would extend the Scout archetype through an application of the Decorator pattern (http://addyosmani.com/blog/decorator-pattern/) and explicitly devise its own retrieval, filtering and formatting strategies by extending the base interfaces and providing their own implemenations.

The directory content of Scout follows rzr style, adhering to the principles of Domain Driven Design (http://domaindrivendesign.org/) by defining a Bounded Context called domain/ by convention. The domain has separate modules, though it is a rzr guiding principle that blades (plugin components) be as minimalistic as possible. Hence, the Scout has one module, scout/. 

The Scout module has an Aggregate Root, conventionally named for the module (in this case, Scout.coffee) which exposes the agents the module provides for external interface.

Modules in rzr style are Agents, though they may not always be very smart. 

A dumb Agent may function much like an ideal Front Controller (http://java.sun.com/blueprints/patterns/FrontController.html) in a traditional Model-View-Controller application, forming an API for the services it provides and delegating requests appropriately. 

More intelligent agents may use their brains to reason about their current context, ensure the safety and validity of the information they have been provided, and align their actions with their models of the world, their beliefs, and their goals.

The Scout archetype is intentionally dumb. Or, perhaps more kindly, naive. It isexpected that domain specific agents will decorate it with intelligence, which is usually domain specific in nature. 

The Scout archetype provides base models for the operations it expects to be able to perform, FilteringStrategy, FormattingStrategy, and RetrievalStrategy which follow the Strategy Pattern for dynamic replacement (http://weblog.bocoup.com/the-strategy-pattern-in-javascript/). These are essentially interfaces that the Scout expects to use to accomplish its purpose, but should be replaced with specific implementations by the decorating scouts.

For convenience, base implementations are also provided that essentially do nothing, NoFormattingStrategy and NoFilteringStrategy. 

Since a common use case is to use scouts to retrieve information from online sources (although conceptually they can be made to retrieve from databases, XML files...conceptually similar to LINQ) an HTTPGetStrategy is provided to do simple HTTP get requests.

The Scout archetype strives to be Simple and Easy, following Rich Hickey's definition (http://www.infoq.com/presentations/Simple-Made-Easy). It provides one basic service to the external world, get. It uses its strategies to get information in the expected format and return it.

Scouts really should not do more than this. Following the Single Responsibility Principle (www.objectmentor.com/resources/articles/srp.pdf), they are intended to be components within a larger system that can be leveraged by others to perform work. If feature functionality beyond the simple use case "Retrieve Information X from Place Y that looks like how I want to see it Z" starts to creep into your implementation, YOAR DOING IT WRONG. Refactor that logic elsewhere.    
